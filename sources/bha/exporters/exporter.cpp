//
// Created by gregorian-rayne on 12/30/25.
//

#include "bha/exporters/exporter.hpp"

#include <nlohmann/json.hpp>

// Embedded resource headers (generated by CMake from resources/)
#include "d3_js.hpp"
#include "fontawesome_css.hpp"
#include "report_head.hpp"
#include "report_body_start.hpp"
#include "report_body_sections.hpp"
#include "report_body_end.hpp"
#include "styles_css.hpp"
#include "visualization_js.hpp"

#include <algorithm>
#include <chrono>
#include <ctime>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <unordered_set>

namespace bha::exporters
{
    namespace {

        /**
         * Formats a timestamp to ISO 8601.
         */
        std::string format_timestamp(const Timestamp ts) {
            const auto time_t_val = std::chrono::system_clock::to_time_t(ts);
            std::ostringstream ss;

#ifdef _WIN32
            std::tm time_info{};
            gmtime_s(&time_info, &time_t_val);
            ss << std::put_time(&time_info, "%Y-%m-%dT%H:%M:%SZ");
#else
            ss << std::put_time(std::gmtime(&time_t_val), "%Y-%m-%dT%H:%M:%SZ");
#endif

            return ss.str();
        }

        /**
         * Formats a duration to milliseconds.
         */
        double duration_to_ms(const Duration d) {
            return static_cast<double>(std::chrono::duration_cast<std::chrono::microseconds>(d).count()) / 1000.0;
        }

        /**
         * Escapes HTML special characters.
         */
        std::string escape_html(const std::string& text) {
            std::string result;
            result.reserve(static_cast<std::size_t>(static_cast<double>(text.size()) * 1.1));
            for (const char c : text) {
                switch (c) {
                case '&': result += "&amp;"; break;
                case '<': result += "&lt;"; break;
                case '>': result += "&gt;"; break;
                case '"': result += "&quot;"; break;
                case '\'': result += "&#39;"; break;
                default: result += c; break;
                }
            }
            return result;
        }

        /**
         * Replaces multiple placeholders in a template string.
         */
        std::string replace_placeholders(const std::string_view tmpl,
                                        const std::vector<std::pair<std::string, std::string>>& replacements) {
            std::string result(tmpl);
            for (const auto& [placeholder, value] : replacements) {
                size_t pos = 0;
                while ((pos = result.find(placeholder, pos)) != std::string::npos) {
                    result.replace(pos, placeholder.length(), value);
                    pos += value.length();
                }
            }
            return result;
        }

        /**
         * Escapes CSV special characters.
         */
        std::string escape_csv(const std::string& text) {
            if (text.find_first_of(",\"\n\r") == std::string::npos) {
                return text;
            }
            std::string result = "\"";
            for (const char c : text) {
                if (c == '"') {
                    result += "\"\"";
                } else {
                    result += c;
                }
            }
            result += "\"";
            return result;
        }

    }  // namespace

    // =============================================================================
    // Format Conversion
    // =============================================================================

    std::string_view format_to_string(const ExportFormat format) noexcept {
        switch (format) {
        case ExportFormat::JSON: return "json";
        case ExportFormat::HTML: return "html";
        case ExportFormat::CSV: return "csv";
        case ExportFormat::SARIF: return "sarif";
        case ExportFormat::Markdown: return "markdown";
        }
        return "unknown";
    }

    std::optional<ExportFormat> string_to_format(const std::string_view str) noexcept {
        if (str == "json" || str == "JSON") return ExportFormat::JSON;
        if (str == "html" || str == "HTML") return ExportFormat::HTML;
        if (str == "csv" || str == "CSV") return ExportFormat::CSV;
        if (str == "sarif" || str == "SARIF") return ExportFormat::SARIF;
        if (str == "markdown" || str == "md" || str == "Markdown") return ExportFormat::Markdown;
        return std::nullopt;
    }

    // =============================================================================
    // Exporter Factory
    // =============================================================================

    Result<std::unique_ptr<IExporter>, Error> ExporterFactory::create(const ExportFormat format) {
        switch (format) {
        case ExportFormat::JSON:
            return Result<std::unique_ptr<IExporter>, Error>::success(
                std::make_unique<JsonExporter>()
            );
        case ExportFormat::HTML:
            return Result<std::unique_ptr<IExporter>, Error>::success(
                std::make_unique<HtmlExporter>()
            );
        case ExportFormat::CSV:
            return Result<std::unique_ptr<IExporter>, Error>::success(
                std::make_unique<CsvExporter>()
            );
        case ExportFormat::Markdown:
            return Result<std::unique_ptr<IExporter>, Error>::success(
                std::make_unique<MarkdownExporter>()
            );
        case ExportFormat::SARIF:
            return Result<std::unique_ptr<IExporter>, Error>::failure(
                Error(ErrorCode::NotFound, "SARIF exporter not yet implemented")
            );
        }
        return Result<std::unique_ptr<IExporter>, Error>::failure(
            Error(ErrorCode::InvalidArgument, "Unknown export format")
        );
    }

    Result<std::unique_ptr<IExporter>, Error> ExporterFactory::create_for_file(const fs::path& path) {
        std::string ext = path.extension().string();
        std::ranges::transform(ext, ext.begin(),
                               [](const unsigned char c) { return static_cast<char>(std::tolower(c)); });

        if (ext == ".json") return create(ExportFormat::JSON);
        if (ext == ".html" || ext == ".htm") return create(ExportFormat::HTML);
        if (ext == ".csv") return create(ExportFormat::CSV);
        if (ext == ".md" || ext == ".markdown") return create(ExportFormat::Markdown);
        if (ext == ".sarif") return create(ExportFormat::SARIF);

        return Result<std::unique_ptr<IExporter>, Error>::failure(
            Error(ErrorCode::InvalidArgument, "Cannot determine format from extension: " + ext)
        );
    }

    std::vector<ExportFormat> ExporterFactory::available_formats() {
        return {
            ExportFormat::JSON,
            ExportFormat::HTML,
            ExportFormat::CSV,
            ExportFormat::Markdown
        };
    }

    // =============================================================================
    // JSON Exporter
    // =============================================================================

    Result<void, Error> JsonExporter::export_to_file(
        const fs::path& path,
        const analyzers::AnalysisResult& analysis,
        const std::vector<Suggestion>& suggestions,
        const ExportOptions& options,
        const ExportProgressCallback progress
    ) const {
        std::ofstream file(path);
        if (!file.is_open()) {
            return Result<void, Error>::failure(
                Error(ErrorCode::IoError, "Failed to open file for writing: " + path.string())
            );
        }
        return export_to_stream(file, analysis, suggestions, options, progress);
    }

    Result<void, Error> JsonExporter::export_to_stream(
        std::ostream& stream,
        const analyzers::AnalysisResult& analysis,
        const std::vector<Suggestion>& suggestions,
        const ExportOptions& options,
        ExportProgressCallback progress
    ) const {
        using json = nlohmann::json;

        json output;

        // Metadata
        if (options.include_metadata) {
            output["$schema"] = "https://bha.dev/schemas/analysis-v" + options.json_schema_version + ".json";
            output["schema_version"] = options.json_schema_version;
            output["bha_version"] = "1.0.0";
            output["generated_at"] = format_timestamp(std::chrono::system_clock::now());
        }

        json summary;
        summary["total_files"] = analysis.files.size();
        summary["total_compile_time_ms"] = duration_to_ms(analysis.performance.total_build_time);
        summary["analysis_duration_ms"] = duration_to_ms(analysis.analysis_duration);
        summary["suggestions_count"] = suggestions.size();
        output["summary"] = summary;

        if (options.include_file_details) {
            json files = json::array();
            std::size_t file_count = 0;
            std::size_t total_files = analysis.files.size();

            for (const auto& file : analysis.files) {
                if (options.min_compile_time > Duration::zero() &&
                    file.compile_time < options.min_compile_time) {
                    continue;
                    }

                if (options.max_files > 0 && file_count >= options.max_files) {
                    break;
                }

                json file_entry;
                file_entry["path"] = file.file.string();
                file_entry["total_time_ms"] = duration_to_ms(file.compile_time);
                file_entry["frontend_time_ms"] = duration_to_ms(file.frontend_time);
                file_entry["backend_time_ms"] = duration_to_ms(file.backend_time);
                file_entry["lines_of_code"] = file.lines_of_code;
                file_entry["include_count"] = file.include_count;

                files.push_back(file_entry);
                file_count++;

                if (progress) {
                    progress(file_count, total_files, "Exporting files");
                }
            }
            output["files"] = files;
        }

        if (options.include_dependencies && !analysis.dependencies.headers.empty()) {
            json deps;
            deps["total_includes"] = analysis.dependencies.total_includes;
            deps["unique_headers"] = analysis.dependencies.unique_headers;
            deps["max_depth"] = analysis.dependencies.max_include_depth;
            deps["circular_dependencies_count"] = analysis.dependencies.circular_dependencies.size();

            json headers_array = json::array();
            for (const auto& [path, total_parse_time, inclusion_count, including_files, included_by, impact_score] : analysis.dependencies.headers) {
                json h;
                h["path"] = path.string();
                h["inclusion_count"] = inclusion_count;
                h["including_files"] = including_files;
                h["parse_time_ms"] = duration_to_ms(total_parse_time);
                h["impact_score"] = impact_score;
                h["included_by"] = included_by;
                headers_array.push_back(h);
            }
            deps["headers"] = headers_array;

            json nodes = json::array();
            json links = json::array();
            std::unordered_set<std::string> seen;

            // Source file nodes
            for (const auto& file : analysis.files) {
                if (std::string file_id = file.file.string(); seen.insert(file_id).second) {
                    nodes.push_back({
                        {"id", file_id},
                        {"type", "source"}
                    });
                }
            }

            // Header nodes
            for (const auto& hinfo : analysis.dependencies.headers) {
                if (std::string hdr_id = hinfo.path.string(); seen.insert(hdr_id).second) {
                    nodes.push_back({
                        {"id", hdr_id},
                        {"type", "header"}
                    });
                }
            }

            // Include links
            for (const auto& hinfo : analysis.dependencies.headers) {
                std::string hdr_id = hinfo.path.string();
                for (const auto& incl_by : hinfo.included_by) {
                    links.push_back({
                        {"source", incl_by},
                        {"target", hdr_id},
                        {"type", "include"}
                    });
                }
            }

            deps["graph"] = {
                {"nodes", nodes},
                {"links", links}
            };

            output["dependencies"] = deps;
        }

        if (options.include_templates && !analysis.templates.templates.empty()) {
            json templates;
            templates["total_instantiations"] = analysis.templates.total_instantiations;
            templates["total_time_ms"] = duration_to_ms(analysis.templates.total_template_time);

            json tmpl_array = json::array();
            for (const auto& tmpl : analysis.templates.templates) {
                json t;
                t["name"] = !tmpl.full_signature.empty() ? tmpl.full_signature : tmpl.name;
                t["type"] = tmpl.name;  // Keep original event type (InstantiateClass, etc.)
                t["count"] = tmpl.instantiation_count;
                t["time_ms"] = duration_to_ms(tmpl.total_time);
                t["time_percent"] = tmpl.time_percent;
                tmpl_array.push_back(t);
            }
            templates["templates"] = tmpl_array;

            output["templates"] = templates;
        }

        if (options.include_symbols && !analysis.symbols.symbols.empty()) {
            json symbols;
            symbols["total_symbols"] = analysis.symbols.total_symbols;
            symbols["unused_symbols"] = analysis.symbols.unused_symbols;

            json sym_array = json::array();
            for (const auto& sym : analysis.symbols.symbols) {
                json s;
                s["name"] = sym.name;
                s["type"] = sym.type;
                s["defined_in"] = sym.defined_in.string();
                s["usage_count"] = sym.usage_count;
                sym_array.push_back(s);
            }
            symbols["symbols"] = sym_array;

            output["symbols"] = symbols;
        }

        if (options.include_suggestions && !suggestions.empty()) {
            json sugg_array = json::array();
            std::size_t sugg_count = 0;

            for (const auto& sugg : suggestions) {
                if (sugg.confidence < options.min_confidence) {
                    continue;
                }
                if (options.max_suggestions > 0 && sugg_count >= options.max_suggestions) {
                    break;
                }

                json sugg_entry;
                sugg_entry["type"] = sugg.type;
                sugg_entry["title"] = sugg.title;
                sugg_entry["description"] = sugg.description;
                sugg_entry["target_file"] = sugg.target_file.path.string();
                sugg_entry["target_line"] = sugg.target_file.line_start;
                sugg_entry["confidence"] = sugg.confidence;
                sugg_entry["priority"] = sugg.priority;
                sugg_entry["estimated_savings_ms"] = duration_to_ms(sugg.estimated_savings);
                sugg_entry["auto_applicable"] = sugg.is_safe;

                if (!sugg.before_code.code.empty()) {
                    sugg_entry["before_code"] = sugg.before_code.code;
                }
                if (!sugg.after_code.code.empty()) {
                    sugg_entry["after_code"] = sugg.after_code.code;
                }

                sugg_array.push_back(sugg_entry);
                sugg_count++;
            }
            output["suggestions"] = sugg_array;
        }

        if (options.pretty_print) {
            stream << std::setw(2) << output << std::endl;
        } else {
            stream << output << std::endl;
        }

        return Result<void, Error>::success();
    }

    Result<std::string, Error> JsonExporter::export_to_string(
        const analyzers::AnalysisResult& analysis,
        const std::vector<Suggestion>& suggestions,
        const ExportOptions& options
    ) const {
        std::ostringstream ss;
        if (auto result = export_to_stream(ss, analysis, suggestions, options, nullptr); result.is_err()) {
            return Result<std::string, Error>::failure(result.error());
        }
        return Result<std::string, Error>::success(ss.str());
    }

    // =============================================================================
    // HTML Exporter
    // =============================================================================

    Result<void, Error> HtmlExporter::export_to_file(
        const fs::path& path,
        const analyzers::AnalysisResult& analysis,
        const std::vector<Suggestion>& suggestions,
        const ExportOptions& options,
        const ExportProgressCallback progress
    ) const {
        std::ofstream file(path);
        if (!file.is_open()) {
            return Result<void, Error>::failure(
                Error(ErrorCode::IoError, "Failed to open file for writing: " + path.string())
            );
        }
        return export_to_stream(file, analysis, suggestions, options, progress);
    }

    Result<void, Error> HtmlExporter::export_to_stream(
        std::ostream& stream,
        const analyzers::AnalysisResult& analysis,
        const std::vector<Suggestion>& suggestions,
        const ExportOptions& options,
        ExportProgressCallback /* progress */
    ) const {
        using namespace bha::resources;

        // Generate embedded JSON data for JavaScript
        ExportOptions json_opts = options;
        json_opts.pretty_print = false;

        JsonExporter json_exporter;
        auto json_result = json_exporter.export_to_string(analysis, suggestions, json_opts);
        if (json_result.is_err()) {
            return Result<void, Error>::failure(json_result.error());
        }

        std::string theme_class = options.html_dark_mode ? "dark-theme" : "light-theme";
        std::string timestamp = format_timestamp(std::chrono::system_clock::now());

        // ==================================================================
        // 1. Build HTML HEAD section
        // ==================================================================
        std::string head = replace_placeholders(REPORT_HEAD_HTML, {
            {"{{TITLE}}", escape_html(options.html_title)},
            {"{{FONTAWESOME_CSS}}", std::string(FONTAWESOME_CSS_DATA)},
            {"{{STYLES_CSS}}", std::string(STYLES_CSS)}
        });

        // ==================================================================
        // 2. Build BODY START section (header + summary cards)
        // ==================================================================
        std::ostringstream summary_stats;
        summary_stats << std::fixed << std::setprecision(1);
        summary_stats << (duration_to_ms(analysis.performance.total_build_time) / 1000.0);
        std::string total_build_time_str = summary_stats.str();

        summary_stats.str("");
        summary_stats << std::fixed << std::setprecision(1);
        summary_stats << duration_to_ms(analysis.performance.avg_file_time);
        std::string avg_file_time_str = summary_stats.str();

        std::string body_start = replace_placeholders(REPORT_BODY_START_HTML, {
            {"{{THEME_CLASS}}", theme_class},
            {"{{TITLE}}", escape_html(options.html_title)},
            {"{{TIMESTAMP}}", timestamp},
            {"{{TOTAL_FILES}}", std::to_string(analysis.files.size())},
            {"{{TOTAL_BUILD_TIME}}", total_build_time_str},
            {"{{AVG_FILE_TIME}}", avg_file_time_str},
            {"{{TOTAL_SUGGESTIONS}}", std::to_string(suggestions.size())}
        });

        // ==================================================================
        // 3. Build FILE TABLE ROWS (dynamic content)
        // ==================================================================
        std::ostringstream file_rows;
        auto sorted_files = analysis.files;
        std::ranges::sort(sorted_files,
                          [](const auto& a, const auto& b) { return a.compile_time > b.compile_time; });

        Duration max_time = sorted_files.empty() ? Duration::zero() : sorted_files[0].compile_time;

        for (const auto& file : sorted_files) {
            double time_ms = duration_to_ms(file.compile_time);
            double fe_ms = duration_to_ms(file.frontend_time);
            double be_ms = duration_to_ms(file.backend_time);
            double bar_width = max_time.count() > 0
                ? 100.0 * static_cast<double>(file.compile_time.count()) / static_cast<double>(max_time.count())
                : 0.0;

            file_rows << "\n                            <tr data-time=\"" << time_ms << "\" data-name=\""
                      << escape_html(file.file.string()) << "\" data-lines=\""
                      << file.lines_of_code << "\">\n"
                      << R"(                                <td><i class="fas fa-file-code" style="color: var(--accent-color); margin-right: 8px;"></i>)"
                      << escape_html(file.file.string()) << "</td>\n"
                      << "                                <td><strong>" << std::fixed << std::setprecision(1) << time_ms << " ms</strong></td>\n"
                      << "                                <td>" << std::fixed << std::setprecision(1) << fe_ms << " ms</td>\n"
                      << "                                <td>" << std::fixed << std::setprecision(1) << be_ms << " ms</td>\n"
                      << "                                <td>" << file.lines_of_code << "</td>\n"
                      << "                                <td>\n"
                      << "                                    <div class=\"time-bar-container\">\n"
                      << R"(                                        <div class="time-bar" style="width: )" << bar_width << "%\"></div>\n"
                      << "                                    </div>\n"
                      << "                                </td>\n"
                      << "                            </tr>";
        }

        // ==================================================================
        // 4. Build SUGGESTION CARDS (dynamic content)
        // ==================================================================
        std::ostringstream suggestion_cards;
        for (const auto& sugg : suggestions) {
            std::string badge_class = "badge-low";
            std::string priority_text = "Low";
            if (sugg.priority == Priority::High || sugg.priority == Priority::Critical) {
                badge_class = "badge-high";
                priority_text = "High";
            } else if (sugg.priority == Priority::Medium) {
                badge_class = "badge-medium";
                priority_text = "Medium";
            }

            suggestion_cards << "\n                <div class=\"suggestion-card\">\n"
                            << "                    <div class=\"suggestion-header\">\n"
                            << "                        <span class=\"suggestion-title\">" << escape_html(sugg.title) << "</span>\n"
                            << "                        <span class=\"suggestion-badge " << badge_class << "\">" << priority_text << "</span>\n"
                            << "                    </div>\n"
                            << "                    <div class=\"suggestion-meta\">\n"
                            << "                        <span class=\"suggestion-meta-item\">\n"
                            << "                            <i class=\"fas fa-map-marker-alt\"></i>\n"
                            << "                            " << escape_html(sugg.target_file.path.string()) << ":" << sugg.target_file.line_start << "\n"
                            << "                        </span>\n"
                            << "                        <span class=\"suggestion-meta-item\">\n"
                            << "                            <i class=\"fas fa-percentage\"></i>\n"
                            << "                            Confidence: " << std::fixed << std::setprecision(0) << (sugg.confidence * 100) << "%\n"
                            << "                        </span>\n"
                            << "                        <span class=\"suggestion-meta-item\">\n"
                            << "                            <i class=\"fas fa-clock\"></i>\n"
                            << "                            Est. savings: " << std::fixed << std::setprecision(1) << duration_to_ms(sugg.estimated_savings) << " ms\n"
                            << "                        </span>\n"
                            << "                    </div>\n"
                            << "                    <p>" << escape_html(sugg.description) << "</p>";

            if (!sugg.before_code.code.empty() || !sugg.after_code.code.empty()) {
                suggestion_cards << "\n                    <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 16px; overflow: hidden;\">";
                if (!sugg.before_code.code.empty()) {
                    suggestion_cards << "\n                        <div style=\"min-width: 0;\">\n"
                                    << "                            <div style=\"font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;\">\n"
                                    << "                                <i class=\"fas fa-times-circle\" style=\"color: var(--danger-color);\"></i> Before:\n"
                                    << "                            </div>\n"
                                    << "                            <pre class=\"code-block\">" << escape_html(sugg.before_code.code) << "</pre>\n"
                                    << "                        </div>";
                }
                if (!sugg.after_code.code.empty()) {
                    suggestion_cards << "\n                        <div style=\"min-width: 0;\">\n"
                                    << "                            <div style=\"font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;\">\n"
                                    << "                                <i class=\"fas fa-check-circle\" style=\"color: var(--success-color);\"></i> After:\n"
                                    << "                            </div>\n"
                                    << "                            <pre class=\"code-block\">" << escape_html(sugg.after_code.code) << "</pre>\n"
                                    << "                        </div>";
                }
                suggestion_cards << "\n                    </div>";
            }

            suggestion_cards << "\n                </div>";
        }

        // ==================================================================
        // 5. Build BODY SECTIONS with placeholders filled
        // ==================================================================
        std::string circular_deps_color = analysis.dependencies.circular_dependencies.empty()
            ? "var(--success-color)"
            : "var(--danger-color)";

        std::string body_sections = replace_placeholders(REPORT_BODY_SECTIONS_HTML, {
            {"{{FILE_TABLE_ROWS}}", file_rows.str()},
            {"{{SUGGESTION_CARDS}}", suggestion_cards.str()},
            {"{{TOTAL_INCLUDES}}", std::to_string(analysis.dependencies.total_includes)},
            {"{{UNIQUE_HEADERS}}", std::to_string(analysis.dependencies.unique_headers)},
            {"{{MAX_INCLUDE_DEPTH}}", std::to_string(analysis.dependencies.max_include_depth)},
            {"{{CIRCULAR_DEPS_COLOR}}", circular_deps_color},
            {"{{CIRCULAR_DEPS_COUNT}}", std::to_string(analysis.dependencies.circular_dependencies.size())}
        });

        // ==================================================================
        // 6. Build BODY END section (D3.js + visualization script)
        // ==================================================================
        std::string body_end = replace_placeholders(REPORT_BODY_END_HTML, {
            {"{{D3_JS}}", std::string(D3_JS_DATA)},
            {"{{ANALYSIS_JSON}}", json_result.value()},
            {"{{VISUALIZATION_JS}}", std::string(VISUALIZATION_JS)}
        });

        // ==================================================================
        // 7. Stream all sections to output
        // ==================================================================
        stream << head
               << body_start
               << body_sections
               << body_end;

        return Result<void, Error>::success();
    }

    Result<std::string, Error> HtmlExporter::export_to_string(
        const analyzers::AnalysisResult& analysis,
        const std::vector<Suggestion>& suggestions,
        const ExportOptions& options
    ) const {
        std::ostringstream ss;
        if (auto result = export_to_stream(ss, analysis, suggestions, options, nullptr); result.is_err()) {
            return Result<std::string, Error>::failure(result.error());
        }
        return Result<std::string, Error>::success(ss.str());
    }

    // =============================================================================
    // CSV Exporter
    // =============================================================================

    Result<void, Error> CsvExporter::export_to_file(
        const fs::path& path,
        const analyzers::AnalysisResult& analysis,
        const std::vector<Suggestion>& suggestions,
        const ExportOptions& options,
        const ExportProgressCallback progress
    ) const {
        std::ofstream file(path);
        if (!file.is_open()) {
            return Result<void, Error>::failure(
                Error(ErrorCode::IoError, "Failed to open file for writing: " + path.string())
            );
        }
        return export_to_stream(file, analysis, suggestions, options, progress);
    }

    Result<void, Error> CsvExporter::export_to_stream(
        std::ostream& stream,
        const analyzers::AnalysisResult& analysis,
        const std::vector<Suggestion>& suggestions,
        const ExportOptions& options,
        ExportProgressCallback
    ) const {
        stream << "# Files\n";
        stream << "Path,Total Time (ms),Frontend Time (ms),Backend Time (ms),Lines of Code,Include Count\n";

        for (const auto& file : analysis.files) {
            if (options.min_compile_time > Duration::zero() &&
                file.compile_time < options.min_compile_time) {
                continue;
                }

            stream << escape_csv(file.file.string()) << ","
                   << std::fixed << std::setprecision(3) << duration_to_ms(file.compile_time) << ","
                   << duration_to_ms(file.frontend_time) << ","
                   << duration_to_ms(file.backend_time) << ","
                   << file.lines_of_code << ","
                   << file.include_count << "\n";
        }

        if (options.include_suggestions && !suggestions.empty()) {
            stream << "\n# Suggestions\n";
            stream << "Type,Title,Target File,Line,Confidence,Priority,Estimated Savings (ms)\n";

            for (const auto& sugg : suggestions) {
                if (sugg.confidence < options.min_confidence) {
                    continue;
                }

                stream << static_cast<int>(sugg.type) << ","
                       << escape_csv(sugg.title) << ","
                       << escape_csv(sugg.target_file.path.string()) << ","
                       << sugg.target_file.line_start << ","
                       << std::fixed << std::setprecision(2) << sugg.confidence << ","
                       << static_cast<int>(sugg.priority) << ","
                       << duration_to_ms(sugg.estimated_savings) << "\n";
            }
        }

        return Result<void, Error>::success();
    }

    Result<std::string, Error> CsvExporter::export_to_string(
        const analyzers::AnalysisResult& analysis,
        const std::vector<Suggestion>& suggestions,
        const ExportOptions& options
    ) const {
        std::ostringstream ss;
        if (auto result = export_to_stream(ss, analysis, suggestions, options, nullptr); result.is_err()) {
            return Result<std::string, Error>::failure(result.error());
        }
        return Result<std::string, Error>::success(ss.str());
    }

    // =============================================================================
    // Markdown Exporter
    // =============================================================================

    Result<void, Error> MarkdownExporter::export_to_file(
        const fs::path& path,
        const analyzers::AnalysisResult& analysis,
        const std::vector<Suggestion>& suggestions,
        const ExportOptions& options,
        const ExportProgressCallback progress
    ) const {
        std::ofstream file(path);
        if (!file.is_open()) {
            return Result<void, Error>::failure(
                Error(ErrorCode::IoError, "Failed to open file for writing: " + path.string())
            );
        }
        return export_to_stream(file, analysis, suggestions, options, progress);
    }

    Result<void, Error> MarkdownExporter::export_to_stream(
        std::ostream& stream,
        const analyzers::AnalysisResult& analysis,
        const std::vector<Suggestion>& suggestions,
        const ExportOptions& options,
        ExportProgressCallback
    ) const {
        stream << "# Build Hotspot Analysis Report\n\n";
        stream << "_Generated by BHA v2.0 on " << format_timestamp(std::chrono::system_clock::now()) << "_\n\n";

        stream << "## Summary\n\n";
        stream << "| Metric | Value |\n";
        stream << "|--------|-------|\n";
        stream << "| Total Files | " << analysis.files.size() << " |\n";
        stream << "| Total Build Time | " << std::fixed << std::setprecision(2)
               << duration_to_ms(analysis.performance.total_build_time) / 1000.0 << " s |\n";
        stream << "| Avg File Time | " << duration_to_ms(analysis.performance.avg_file_time) << " ms |\n";
        stream << "| Parallelism Efficiency | " << std::setprecision(1) << (analysis.performance.parallelism_efficiency * 100.0) << "% |\n";
        stream << "| Suggestions | " << suggestions.size() << " |\n\n";

        if (options.include_file_details) {
            stream << "## Top Files by Compile Time\n\n";
            stream << "| File | Time (ms) | Frontend | Backend | LOC |\n";
            stream << "|------|-----------|----------|---------|-----|\n";

            auto sorted_files = analysis.files;
            std::ranges::sort(sorted_files,
                              [](const auto& a, const auto& b) { return a.compile_time > b.compile_time; });

            std::size_t count = 0;
            for (const auto& file : sorted_files) {
                if (options.max_files > 0 && count >= options.max_files) break;
                if (count >= 20) break;  // Default limit for Markdown

                stream << "| " << file.file.filename().string()
                       << " | " << std::fixed << std::setprecision(1) << duration_to_ms(file.compile_time)
                       << " | " << duration_to_ms(file.frontend_time)
                       << " | " << duration_to_ms(file.backend_time)
                       << " | " << file.lines_of_code << " |\n";
                count++;
            }
            stream << "\n";
        }

        if (options.include_suggestions && !suggestions.empty()) {
            stream << "## Optimization Suggestions\n\n";

            for (const auto& sugg : suggestions) {
                if (sugg.confidence < options.min_confidence) continue;

                std::string priority;
                switch (sugg.priority) {
                case Priority::Critical: priority = "CRITICAL"; break;
                case Priority::High: priority = "HIGH"; break;
                case Priority::Medium: priority = "MEDIUM"; break;
                case Priority::Low: priority = "LOW"; break;
                }

                stream << "### " << sugg.title << "\n\n";
                stream << "**Priority:** " << priority
                       << " | **Confidence:** " << std::fixed << std::setprecision(0)
                       << (sugg.confidence * 100) << "%"
                       << " | **Est. Savings:** " << std::setprecision(1)
                       << duration_to_ms(sugg.estimated_savings) << " ms\n\n";
                stream << "**File:** `" << sugg.target_file.path.string() << ":" << sugg.target_file.line_start << "`\n\n";
                stream << sugg.description << "\n\n";

                if (!sugg.before_code.code.empty()) {
                    stream << "**Before:**\n```cpp\n" << sugg.before_code.code << "\n```\n\n";
                }
                if (!sugg.after_code.code.empty()) {
                    stream << "**After:**\n```cpp\n" << sugg.after_code.code << "\n```\n\n";
                }

                stream << "---\n\n";
            }
        }

        if (options.include_dependencies) {
            stream << "## Dependency Analysis\n\n";
            stream << "- **Total Includes:** " << analysis.dependencies.total_includes << "\n";
            stream << "- **Unique Headers:** " << analysis.dependencies.unique_headers << "\n";
            stream << "- **Max Include Depth:** " << analysis.dependencies.max_include_depth << "\n";
            stream << "- **Circular Dependencies:** " << analysis.dependencies.circular_dependencies.size() << "\n\n";
        }

        return Result<void, Error>::success();
    }

    Result<std::string, Error> MarkdownExporter::export_to_string(
        const analyzers::AnalysisResult& analysis,
        const std::vector<Suggestion>& suggestions,
        const ExportOptions& options
    ) const {
        std::ostringstream ss;
        if (auto result = export_to_stream(ss, analysis, suggestions, options, nullptr); result.is_err()) {
            return Result<std::string, Error>::failure(result.error());
        }
        return Result<std::string, Error>::success(ss.str());
    }
} // namespace bha::exporters
