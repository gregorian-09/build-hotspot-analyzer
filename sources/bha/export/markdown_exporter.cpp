//
// Created by gregorian on 23/10/2025.
//

#include "bha/export/markdown_exporter.h"
#include "bha/utils/file_utils.h"
#include <sstream>
#include <iomanip>
#include <utility>

namespace bha::export_module {

    MarkdownExporter::MarkdownExporter(Options options)
        : options_(std::move(options)) {}

    core::Result<void> MarkdownExporter::export_report(
        const core::MetricsSummary& metrics,
        const std::vector<core::Suggestion>& suggestions,
        const core::BuildTrace& trace,
        const std::string& output_path
    ) {
        std::ostringstream md;

        md << "# Build Hotspot Analysis Report\n\n";

        md << "**Build System:** " << trace.build_system << "  \n";
        md << "**Configuration:** " << trace.configuration << "  \n";
        md << "**Platform:** " << trace.platform << "  \n";
        md << "**Total Build Time:** " << trace.total_build_time_ms << " ms\n\n";

        if (options_.include_toc) {
            md << generate_table_of_contents();
        }

        md << generate_metrics_section(metrics);
        md << generate_hotspots_table(metrics);
        md << generate_suggestions_section(suggestions);

        md << "\n---\n\n";
        md << "*Generated by Build Hotspot Analyzer v1.0.0*\n";

        if (!utils::write_file(output_path, md.str())) {
            return core::Result<void>::failure(core::Error(
                core::ErrorCode::FILE_WRITE_ERROR,
                "Failed to write Markdown to: " + output_path
            ));
        }

        return core::Result<void>::success();
    }

    std::string MarkdownExporter::generate_table_of_contents() {
        return "## Table of Contents\n\n"
               "1. [Summary Metrics](#summary-metrics)\n"
               "2. [Top Hotspots](#top-hotspots)\n"
               "3. [Optimization Suggestions](#optimization-suggestions)\n\n";
    }

    std::string MarkdownExporter::generate_metrics_section(const core::MetricsSummary& metrics) {
        std::ostringstream md;

        md << "## Summary Metrics\n\n";

        md << "| Metric | Value |\n";
        md << "|--------|-------|\n";
        md << "| Total Files Compiled | " << metrics.total_files_compiled << " |\n";
        md << "| Total Headers Parsed | " << metrics.total_headers_parsed << " |\n";
        md << "| Average Compile Time | " << std::fixed << std::setprecision(2)
           << metrics.average_file_time_ms << " ms |\n";
        md << "| Median Compile Time | " << std::fixed << std::setprecision(2)
           << metrics.median_file_time_ms << " ms |\n";
        md << "| P95 Compile Time | " << std::fixed << std::setprecision(2)
           << metrics.p95_file_time_ms << " ms |\n";
        md << "| P99 Compile Time | " << std::fixed << std::setprecision(2)
           << metrics.p99_file_time_ms << " ms |\n";
        md << "| Total Dependencies | " << metrics.total_dependencies << " |\n";
        md << "| Average Include Depth | " << metrics.average_include_depth << " |\n";
        md << "| Max Include Depth | " << metrics.max_include_depth << " |\n";
        md << "| Circular Dependencies | " << metrics.circular_dependency_count << " |\n";

        md << "\n";

        return md.str();
    }

    std::string MarkdownExporter::generate_hotspots_table(const core::MetricsSummary& metrics) const {
        std::ostringstream md;

        md << "## Top Hotspots\n\n";

        md << "| Rank | File | Time (ms) | Impact Score | Dependents | Category |\n";
        md << "|------|------|-----------|--------------|------------|----------|\n";

        int rank = 1;
        for (const auto& [file_path, time_ms, impact_score, num_dependent_files, category] : metrics.top_slow_files) {
            md << "| " << rank++ << " | ";

            if (options_.include_code_blocks) {
                md << "`" << escape_markdown(file_path) << "`";
            } else {
                md << escape_markdown(file_path);
            }

            md << " | " << std::fixed << std::setprecision(2) << time_ms
               << " | " << std::fixed << std::setprecision(2) << impact_score
               << " | " << num_dependent_files
               << " | " << escape_markdown(category) << " |\n";
        }

        md << "\n";

        return md.str();
    }

    std::string MarkdownExporter::generate_suggestions_section(
        const std::vector<core::Suggestion>& suggestions
    ) {
        std::ostringstream md;

        md << "## Optimization Suggestions\n\n";

        if (suggestions.empty()) {
            md << "*No suggestions available.*\n\n";
            return md.str();
        }

        int suggestion_num = 1;
        for (const auto& suggestion : suggestions) {
            md << "### " << suggestion_num++ << ". "
               << escape_markdown(suggestion.title) << "\n\n";

            std::string priority_badge;
            switch (suggestion.priority) {
                case core::Priority::CRITICAL:
                    priority_badge = "**CRITICAL**";
                    break;
                case core::Priority::HIGH:
                    priority_badge = "**HIGH**";
                    break;
                case core::Priority::MEDIUM:
                    priority_badge = "**MEDIUM**";
                    break;
                case core::Priority::LOW:
                    priority_badge = "**LOW**";
                    break;
            }

            md << priority_badge << " | ";
            md << "Confidence: " << std::fixed << std::setprecision(0)
               << (suggestion.confidence * 100) << "% | ";
            md << "Estimated Savings: " << std::fixed << std::setprecision(2)
               << suggestion.estimated_time_savings_ms << " ms";

            if (suggestion.estimated_time_savings_percent > 0) {
                md << " (" << std::fixed << std::setprecision(1)
                   << suggestion.estimated_time_savings_percent << "%)";
            }
            md << "\n\n";

            md << escape_markdown(suggestion.description) << "\n\n";

            if (!suggestion.file_path.empty()) {
                md << "**Affected File:** `" << escape_markdown(suggestion.file_path) << "`\n\n";
            }

            if (!suggestion.related_files.empty()) {
                md << "**Related Files:**\n";
                for (const auto& file : suggestion.related_files) {
                    md << "- `" << escape_markdown(file) << "`\n";
                }
                md << "\n";
            }

            if (!suggestion.rationale.empty()) {
                md << "**Rationale:** " << escape_markdown(suggestion.rationale) << "\n\n";
            }

            if (!suggestion.is_safe) {
                md << "> ⚠️ **Warning:** This suggestion requires careful review before applying.\n\n";
            }

            md << "---\n\n";
        }

        return md.str();
    }

    std::string MarkdownExporter::escape_markdown(const std::string& text) {
        std::string escaped;
        escaped.reserve(text.size());

        for (const char c : text) {
            switch (c) {
                case '\\':
                case '`':
                case '*':
                case '_':
                case '{':
                case '}':
                case '[':
                case ']':
                case '(':
                case ')':
                case '#':
                case '+':
                case '-':
                case '.':
                case '!':
                case '|':
                    escaped += '\\';
                    escaped += c;
                    break;
                default:
                    escaped += c;
            }
        }

        return escaped;
    }
}