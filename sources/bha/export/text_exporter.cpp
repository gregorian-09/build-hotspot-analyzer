//
// Created by gregorian on 23/10/2025.
//

#include "bha/export/text_exporter.h"
#include "bha/utils/file_utils.h"
#include <sstream>
#include <iomanip>

namespace bha::export_module {

    TextExporter::TextExporter(const Options& options)
        : options_(options) {}

    core::Result<void> TextExporter::export_report(
        const core::MetricsSummary& metrics,
        const std::vector<core::Suggestion>& suggestions,
        const core::BuildTrace& trace,
        const std::string& output_path
    ) {
        std::ostringstream text;

        text << generate_header(trace);
        text << generate_metrics_section(metrics);
        text << generate_hotspots_section(metrics);
        text << generate_suggestions_section(suggestions);

        text << "\n" << std::string(80, '=') << "\n";
        text << "Generated by Build Hotspot Analyzer v1.0.0\n";

        if (!utils::write_file(output_path, text.str())) {
            return core::Result<void>::failure(core::Error{
                core::ErrorCode::FILE_WRITE_ERROR,
                "Failed to write text report to: " + output_path
            });
        }

        return core::Result<void>::success();
    }

    std::string TextExporter::generate_header(const core::BuildTrace& trace) const
    {
        std::ostringstream text;

        text << std::string(80, '=') << "\n";
        text << colorize("BUILD HOTSPOT ANALYSIS REPORT", "bold") << "\n";
        text << std::string(80, '=') << "\n\n";

        text << "Build System:    " << trace.build_system << "\n";
        text << "Configuration:   " << trace.configuration << "\n";
        text << "Platform:        " << trace.platform << "\n";
        text << "Total Build Time: " << std::fixed << std::setprecision(2)
             << trace.total_build_time_ms << " ms\n";
        text << "\n";

        return text.str();
    }

    std::string TextExporter::generate_metrics_section(const core::MetricsSummary& metrics) const
    {
        std::ostringstream text;

        text << std::string(80, '-') << "\n";
        text << colorize("SUMMARY METRICS", "bold") << "\n";
        text << std::string(80, '-') << "\n\n";

        if (!options_.compact_mode) {
            text << "Compilation Statistics:\n";
            text << "  Total Files Compiled:     " << metrics.total_files_compiled << "\n";
            text << "  Total Headers Parsed:     " << metrics.total_headers_parsed << "\n";
            text << "  Average Compile Time:     " << std::fixed << std::setprecision(2)
                 << metrics.average_file_time_ms << " ms\n";
            text << "  Median Compile Time:      " << metrics.median_file_time_ms << " ms\n";
            text << "  P95 Compile Time:         " << metrics.p95_file_time_ms << " ms\n";
            text << "  P99 Compile Time:         " << metrics.p99_file_time_ms << " ms\n";
            text << "\n";

            text << "Dependency Statistics:\n";
            text << "  Total Dependencies:       " << metrics.total_dependencies << "\n";
            text << "  Average Include Depth:    " << metrics.average_include_depth << "\n";
            text << "  Max Include Depth:        " << metrics.max_include_depth << "\n";
            text << "  Circular Dependencies:    " << metrics.circular_dependency_count;

            if (metrics.circular_dependency_count > 0) {
                text << " " << colorize("⚠️", "yellow");
            }
            text << "\n\n";
        } else {
            text << "Files: " << metrics.total_files_compiled
                 << " | Avg: " << std::fixed << std::setprecision(0) << metrics.average_file_time_ms << "ms"
                 << " | P95: " << metrics.p95_file_time_ms << "ms"
                 << " | Depth: " << metrics.max_include_depth << "\n\n";
        }

        return text.str();
    }

    std::string TextExporter::generate_hotspots_section(const core::MetricsSummary& metrics) const
    {
        std::ostringstream text;

        text << std::string(80, '-') << "\n";
        text << colorize("TOP HOTSPOTS", "bold") << "\n";
        text << std::string(80, '-') << "\n\n";

        if (metrics.top_slow_files.empty()) {
            text << "  No hotspots identified.\n\n";
            return text.str();
        }

        int rank = 1;
        for (const auto& hotspot : metrics.top_slow_files) {
            if (rank > 20) break;

            std::string color = "default";
            if (hotspot.time_ms > metrics.p99_file_time_ms) {
                color = "red";
            } else if (hotspot.time_ms > metrics.p95_file_time_ms) {
                color = "yellow";
            }

            text << colorize(std::to_string(rank) + ". ", "bold");
            text << truncate_path(hotspot.file_path, options_.max_path_length) << "\n";
            text << "   Time: " << colorize(std::to_string(static_cast<int>(hotspot.time_ms)) + " ms", color);
            text << " | Impact: " << std::fixed << std::setprecision(2) << hotspot.impact_score;
            text << " | Dependents: " << hotspot.num_dependent_files;
            text << " | Category: " << hotspot.category << "\n";

            constexpr double bar_width = 50.0;
            const double max_time = metrics.top_slow_files[0].time_ms;
            const int bars = static_cast<int>((hotspot.time_ms / max_time) * bar_width);
            text << "   " << colorize(std::string(bars, '|'), color) << "\n\n";

            rank++;
        }

        return text.str();
    }

    std::string TextExporter::generate_suggestions_section(
        const std::vector<core::Suggestion>& suggestions
    ) const
    {
        std::ostringstream text;

        text << std::string(80, '-') << "\n";
        text << colorize("OPTIMIZATION SUGGESTIONS", "bold") << "\n";
        text << std::string(80, '-') << "\n\n";

        if (suggestions.empty()) {
            text << "  No suggestions available.\n\n";
            return text.str();
        }

        int num = 1;
        for (const auto& suggestion : suggestions) {
            if (num > 10) break;

            std::string priority_marker;
            std::string priority_color = "default";

            switch (suggestion.priority) {
                case core::Priority::CRITICAL:
                    priority_marker = "[CRITICAL]";
                    priority_color = "red";
                    break;
                case core::Priority::HIGH:
                    priority_marker = "[HIGH]    ";
                    priority_color = "yellow";
                    break;
                case core::Priority::MEDIUM:
                    priority_marker = "[MEDIUM]  ";
                    priority_color = "cyan";
                    break;
                case core::Priority::LOW:
                    priority_marker = "[LOW]     ";
                    priority_color = "green";
                    break;
            }

            text << colorize(std::to_string(num) + ". ", "bold");
            text << colorize(priority_marker, priority_color) << " ";
            text << suggestion.title << "\n";

            if (!options_.compact_mode) {
                text << "   " << suggestion.description << "\n";

                if (!suggestion.file_path.empty()) {
                    text << "   File: " << truncate_path(suggestion.file_path, options_.max_path_length - 9) << "\n";
                }

                text << "   Savings: " << std::fixed << std::setprecision(2)
                     << suggestion.estimated_time_savings_ms << " ms";

                if (suggestion.estimated_time_savings_percent > 0) {
                    text << " (" << std::fixed << std::setprecision(1)
                         << suggestion.estimated_time_savings_percent << "%)";
                }

                text << " | Confidence: " << std::fixed << std::setprecision(0)
                     << (suggestion.confidence * 100) << "%\n";

                if (!suggestion.is_safe) {
                    text << "   " << colorize("⚠️  Warning: Requires careful review", "yellow") << "\n";
                }
            }

            text << "\n";
            num++;
        }

        return text.str();
    }

    std::string TextExporter::colorize(const std::string& text, const std::string& color) const
    {
        if (!options_.use_colors) {
            return text;
        }

        std::string code;
        if (color == "red") code = "\033[31m";
        else if (color == "green") code = "\033[32m";
        else if (color == "yellow") code = "\033[33m";
        else if (color == "cyan") code = "\033[36m";
        else if (color == "bold") code = "\033[1m";
        else return text;

        return code + text + "\033[0m";
    }

    std::string TextExporter::truncate_path(const std::string& path, const int max_length) {
        if (static_cast<int>(path.length()) <= max_length) {
            return path;
        }

        const int keep_start = max_length / 3;
        const int keep_end = max_length - keep_start - 3;

        return path.substr(0, keep_start) + "..." + path.substr(path.length() - keep_end);
    }
}
